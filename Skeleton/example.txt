

ðŸ”¹ General Template for Any Spring Boot Deployment

No matter the project, youâ€™ll always need to define a few core resources:

1. Networking

VPC (your private network in AWS)

Subnets (usually: public for app, private for DB/cache)

Internet Gateway + Route Tables (for internet access)


2. Security

Security Groups (firewall rules â†’ define who can talk to who)

EC2 â†’ allow SSH (22), app port (8080 or 80)

DB (RDS) â†’ allow only from EC2 SG


Key Pair (for SSH login to EC2)


3. Compute (Spring Boot App Hosting)

EC2 Instance (small app, simple projects)

or ECS/EKS (if containerized / microservices)


4. Database (if needed)

RDS (MySQL/Postgres) in private subnet

or DynamoDB (if NoSQL)


5. (Optional) Load Balancer

ALB (so app is available at http://myapp.com instead of EC2 IP)



---

ðŸ”¹ Generic Terraform Skeleton

This template can be reused for almost any Spring Boot project:

provider "aws" {
  region = "us-east-1"
}

# 1. VPC
resource "aws_vpc" "app_vpc" {
  cidr_block = "10.0.0.0/16"
}

# 2. Subnets (public + private)
resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.app_vpc.id
  cidr_block              = "10.0.1.0/24"
  map_public_ip_on_launch = true
}

resource "aws_subnet" "private" {
  vpc_id     = aws_vpc.app_vpc.id
  cidr_block = "10.0.2.0/24"
}

# 3. Internet Gateway + Route Table
resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.app_vpc.id
}

resource "aws_route_table" "public_rt" {
  vpc_id = aws_vpc.app_vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.gw.id
  }
}

resource "aws_route_table_association" "public_assoc" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public_rt.id
}

# 4. Security Groups
resource "aws_security_group" "ec2_sg" {
  vpc_id = aws_vpc.app_vpc.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_db_subnet_group" "db_subnet" {
  name       = "mydb-subnet-group"
  subnet_ids = [aws_subnet.private.id]   # place DB inside private subnet

  tags = {
    Name = "MyDBSubnetGroup"
  }
}

# 5. EC2 Instance
resource "aws_instance" "app_server" {
  ami           = "ami-0c02fb55956c7d316" # Amazon Linux 2
  instance_type = "t2.micro"
  subnet_id     = aws_subnet.public.id
  key_name      = "my-key"
  vpc_security_group_ids = [aws_security_group.ec2_sg.id]

  tags = {
    Name = "SpringBootApp"
  }
}

# 6. (Optional) Database
resource "aws_db_instance" "mydb" {
  allocated_storage    = 20
  engine               = "mysql"
  instance_class       = "db.t3.micro"
  name                 = "mydb"
  username             = "admin"
  password             = "password123"
  skip_final_snapshot  = true

  vpc_security_group_ids = [aws_security_group.ec2_sg.id]
  db_subnet_group_name   = aws_db_subnet_group.db_subnet.id
}


---

ðŸ”¹ Takeaway for You

Whenever you start a new Spring Boot project, just think:

ðŸ‘‰ Do I need only app server (EC2) or also a DB (RDS)?
ðŸ‘‰ Will my app be public (exposed to internet) or private (internal only)?
ðŸ‘‰ Do I want manual setup (console) or repeatable infra (Terraform)?

Thatâ€™s it.




